<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Labyrinth Tilt Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #121212;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent scrolling */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* The wooden box container */
        .wood-frame {
            position: relative;
            padding: 15px;
            background-color: #8b5a2b;
            /* Procedural wood texture */
            background-image: 
                repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 2px, transparent 2px, transparent 4px),
                linear-gradient(to bottom, #a06e3b, #6e4620);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid #4a2e13;
        }

        canvas {
            display: block;
            border-radius: 6px;
            background: #333;
            box-shadow: inset 0 0 10px #000;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            color: white;
            text-align: center;
            border-radius: 12px;
            backdrop-filter: blur(2px);
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            color: #d4af37;
            text-shadow: 2px 2px 0px #000;
        }

        p {
            margin: 0 0 25px 0;
            font-size: 1.1rem;
            color: #ccc;
            max-width: 80%;
            line-height: 1.5;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            background: linear-gradient(to bottom, #d4af37, #aa8c2c);
            border: 1px solid #ffe680;
            color: #222;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            transition: transform 0.1s, filter 0.1s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:active {
            transform: scale(0.95);
            filter: brightness(0.9);
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #level-indicator {
            position: absolute;
            top: 5px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.3);
            font-size: 12px;
            pointer-events: none;
            font-weight: bold;
            text-transform: uppercase;
        }
    </style>
</head>
<body>

    <div class="wood-frame">
        <div id="level-indicator">Level 1</div>
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer">
            <h1 id="ui-title">Labyrinth</h1>
            <p id="ui-text">Tilt your phone to guide the ball.<br>Avoid the holes!</p>
            <button id="action-btn" class="btn">Start Game</button>
        </div>
    </div>

<script>
/**
 * ------------------------------------------------------------------
 * LEVEL CONFIGURATION
 * ------------------------------------------------------------------
 * 0 = Floor
 * 1 = Wall
 * 2 = Hole
 * 3 = Start Position (Ball spawns here)
 * 4 = Goal (Green Hole)
 */
const LEVELS = [
    // LEVEL 1: U-shape
    [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 0, 0, 2, 0, 0, 2, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    // LEVEL 2: Zig-zag
    [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
        [1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ]
];

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiLayer = document.getElementById('ui-layer');
const uiTitle = document.getElementById('ui-title');
const uiText = document.getElementById('ui-text');
const actionBtn = document.getElementById('action-btn');
const levelIndicator = document.getElementById('level-indicator');

// --- PHYSICS CONSTANTS ---
const FRICTION = 0.96;       
const SENSITIVITY = 0.8;     
const MAX_VELOCITY = 15;     
const GRAVITY_SCALE = 0.5;   
const DEADZONE = 2;          
const BOUNCE = 0.4; 

// State
let currentLevelIdx = 0;
let isPlaying = false;
let tiltX = 0, tiltY = 0;
let gameScale = 1;
let animationFrameId = null; // Track the loop ID to prevent stacking

// Entities
let ball = { x:0, y:0, vx:0, vy:0, r:0, color: '#e74c3c' };
let holes = [];
let walls = []; 
let goal = null;

// Keyboard State
const keys = { Up:false, Down:false, Left:false, Right:false };

// --- SETUP & RESIZE ---

function loadLevel(index) {
    if (index >= LEVELS.length) {
        gameComplete();
        return;
    }

    currentLevelIdx = index;
    levelIndicator.textContent = `Level ${index + 1}`;
    
    const grid = LEVELS[index];
    const rows = grid.length;
    const cols = grid[0].length;

    // Calculate Scale
    const maxWidth = window.innerWidth - 40;
    const maxHeight = window.innerHeight - 40;
    
    gameScale = Math.min(maxWidth / cols, maxHeight / rows);
    
    canvas.width = cols * gameScale;
    canvas.height = rows * gameScale;

    // Reset Entities
    holes = [];
    walls = [];
    goal = null;
    ball.vx = 0;
    ball.vy = 0;
    ball.r = (gameScale / 2) * 0.75; 

    // Parse Grid
    for(let r=0; r<rows; r++){
        for(let c=0; c<cols; c++){
            const type = grid[r][c];
            const cx = c * gameScale + gameScale/2;
            const cy = r * gameScale + gameScale/2;

            if(type === 1) {
                walls.push({ c: c, r: r }); 
            } else if(type === 2) {
                holes.push({ x: cx, y: cy, r: gameScale * 0.35 });
            } else if(type === 3) {
                ball.x = cx;
                ball.y = cy;
            } else if(type === 4) {
                goal = { x: cx, y: cy, r: gameScale * 0.4 };
            }
        }
    }
}

function resize() {
    if(isPlaying) {
        const oldScale = gameScale;
        const relX = ball.x / oldScale;
        const relY = ball.y / oldScale;
        
        loadLevel(currentLevelIdx);
        
        ball.x = relX * gameScale;
        ball.y = relY * gameScale;
    } else {
        loadLevel(currentLevelIdx);
    }
    draw();
}

// --- GAME LOOP ---

function update() {
    if(!isPlaying) return;

    // 1. Calculate Forces
    let ax = 0;
    let ay = 0;

    // Keyboard Fallback
    if(keys.Up) ay = -15;
    if(keys.Down) ay = 15;
    if(keys.Left) ax = -15;
    if(keys.Right) ax = 15;

    // Tilt Logic
    if(Math.abs(tiltX) > DEADZONE || Math.abs(tiltY) > DEADZONE) {
        let tx = Math.abs(tiltX) > DEADZONE ? tiltX : 0;
        let ty = Math.abs(tiltY) > DEADZONE ? tiltY : 0;

        ax = tx * SENSITIVITY * GRAVITY_SCALE;
        ay = ty * SENSITIVITY * GRAVITY_SCALE;
    }

    // Apply Acceleration
    ball.vx += ax * 0.1;
    ball.vy += ay * 0.1;
    
    // Apply Friction
    ball.vx *= FRICTION;
    ball.vy *= FRICTION;

    // Velocity Clamping
    if (ball.vx > MAX_VELOCITY) ball.vx = MAX_VELOCITY;
    if (ball.vx < -MAX_VELOCITY) ball.vx = -MAX_VELOCITY;
    if (ball.vy > MAX_VELOCITY) ball.vy = MAX_VELOCITY;
    if (ball.vy < -MAX_VELOCITY) ball.vy = -MAX_VELOCITY;

    // 2. Move
    ball.x += ball.vx;
    ball.y += ball.vy;

    // 3. Wall Collision
    checkWallCollisions();

    // 4. Hole Collision
    for(let h of holes) {
        const dist = Math.hypot(ball.x - h.x, ball.y - h.y);
        if(dist < h.r * 0.6) { 
            playerDied();
            return;
        }
    }

    // 5. Goal Collision
    if(goal) {
        const dist = Math.hypot(ball.x - goal.x, ball.y - goal.y);
        if(dist < goal.r * 0.5) {
            levelComplete();
            return;
        }
    }

    draw();
    // Save the ID so we can cancel it if needed
    animationFrameId = requestAnimationFrame(update);
}

function checkWallCollisions() {
    // Check Canvas Bounds
    if(ball.x < ball.r) { ball.x = ball.r; ball.vx *= -BOUNCE; }
    if(ball.y < ball.r) { ball.y = ball.r; ball.vy *= -BOUNCE; }
    if(ball.x > canvas.width - ball.r) { ball.x = canvas.width - ball.r; ball.vx *= -BOUNCE; }
    if(ball.y > canvas.height - ball.r) { ball.y = canvas.height - ball.r; ball.vy *= -BOUNCE; }

    // Check Grid Walls
    const col = Math.floor(ball.x / gameScale);
    const row = Math.floor(ball.y / gameScale);

    for(let r = row - 1; r <= row + 1; r++) {
        for(let c = col - 1; c <= col + 1; c++) {
            const isWall = walls.some(w => w.c === c && w.r === r);
            if(isWall) {
                resolveRectCollision(c * gameScale, r * gameScale, gameScale);
            }
        }
    }
}

function resolveRectCollision(wx, wy, size) {
    let testX = ball.x;
    let testY = ball.y;

    if (ball.x < wx) testX = wx;
    else if (ball.x > wx + size) testX = wx + size;
    
    if (ball.y < wy) testY = wy;
    else if (ball.y > wy + size) testY = wy + size;

    const distX = ball.x - testX;
    const distY = ball.y - testY;
    const distance = Math.sqrt(distX*distX + distY*distY);

    if (distance <= ball.r) {
        let nx = distX / distance;
        let ny = distY / distance;
        
        if(distance === 0) { nx=1; ny=0; } 

        const overlap = ball.r - distance;
        ball.x += nx * overlap;
        ball.y += ny * overlap;

        const dot = ball.vx * nx + ball.vy * ny;
        ball.vx = (ball.vx - 2 * dot * nx) * BOUNCE;
        ball.vy = (ball.vy - 2 * dot * ny) * BOUNCE;
    }
}

// --- RENDERING ---

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 1. Floor Texture
    const floorGrad = ctx.createLinearGradient(0,0, canvas.width, canvas.height);
    floorGrad.addColorStop(0, '#555');
    floorGrad.addColorStop(1, '#333');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0,0, canvas.width, canvas.height);

    // 2. Walls
    ctx.fillStyle = '#222';
    for(let w of walls) {
        ctx.fillRect(w.c * gameScale, w.r * gameScale, gameScale+1, gameScale+1);
    }
    
    // Wall Tops
    ctx.fillStyle = '#3a3a3a'; 
    const bevel = gameScale * 0.1;
    for(let w of walls) {
        ctx.fillRect(
            w.c * gameScale + bevel, 
            w.r * gameScale + bevel, 
            gameScale - bevel*2, 
            gameScale - bevel*2
        );
    }

    // 3. Holes
    for(let h of holes) {
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.r, 0, Math.PI*2);
        const g = ctx.createRadialGradient(h.x, h.y, h.r*0.2, h.x, h.y, h.r);
        g.addColorStop(0, '#000');
        g.addColorStop(1, 'rgba(0,0,0,0.5)');
        ctx.fillStyle = g;
        ctx.fill();
    }

    // 4. Goal
    if(goal) {
        ctx.beginPath();
        ctx.arc(goal.x, goal.y, goal.r, 0, Math.PI*2);
        ctx.fillStyle = '#000';
        ctx.fill();
        
        ctx.save();
        ctx.clip();
        ctx.fillStyle = '#0f0';
        const s = goal.r / 2.5;
        for(let x=goal.x-goal.r; x<goal.x+goal.r; x+=s) {
            for(let y=goal.y-goal.r; y<goal.y+goal.r; y+=s) {
                if((Math.floor(x/s) + Math.floor(y/s)) % 2 === 0) 
                    ctx.fillRect(x,y,s,s);
            }
        }
        ctx.restore();
    }

    // 5. Ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
    
    // Shine
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath();
    ctx.arc(ball.x - ball.r*0.3, ball.y - ball.r*0.3, ball.r/2, 0, Math.PI * 2);
    ctx.fill();
    ctx.closePath();
}

// --- GAME STATE MANAGEMENT ---

function playerDied() {
    isPlaying = false;
    showUI("You Fell!", "Watch out for the holes.", "Try Again");
    
    // Override button for Restart
    actionBtn.onclick = () => {
        loadLevel(currentLevelIdx);
        startGame();
    };
}

function levelComplete() {
    isPlaying = false;
    if(currentLevelIdx < LEVELS.length - 1) {
        showUI("Level Complete!", "Great job!", "Next Level");
        // Override button for Next Level
        actionBtn.onclick = () => {
            loadLevel(currentLevelIdx + 1);
            startGame();
        };
    } else {
        gameComplete();
    }
}

function gameComplete() {
    showUI("You Win!", "You beat all levels!", "Play Again");
    // Override button for Reset
    actionBtn.onclick = () => {
        loadLevel(0);
        startGame();
    };
}

function showUI(title, text, btnText) {
    uiTitle.textContent = title;
    uiText.textContent = text;
    actionBtn.textContent = btnText;
    uiLayer.classList.remove('hidden');
}

function startGame() {
    uiLayer.classList.add('hidden');
    isPlaying = true;
    
    // CRITICAL FIX: Cancel any existing loop to prevent double-speed physics
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
    
    update();
}

// --- INPUT HANDLERS ---

// Initial Button Logic (Replaces addEventListener to avoid conflicts)
actionBtn.onclick = async () => {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
            const permission = await DeviceOrientationEvent.requestPermission();
            if (permission === 'granted') {
                window.addEventListener('deviceorientation', handleTilt);
                startGame();
            } else {
                alert("Gyroscope permission denied. Use keyboard.");
                startGame();
            }
        } catch (e) {
            startGame();
        }
    } else {
        window.addEventListener('deviceorientation', handleTilt);
        startGame();
    }
};

function handleTilt(e) {
    let x = e.gamma; 
    let y = e.beta;  
    
    if(x > 45) x = 45; if(x < -45) x = -45;
    if(y > 45) y = 45; if(y < -45) y = -45;

    tiltX = x;
    tiltY = y;
}

// Keyboard
window.addEventListener('keydown', e => {
    if(e.key === 'ArrowUp' || e.key === 'w') keys.Up = true;
    if(e.key === 'ArrowDown' || e.key === 's') keys.Down = true;
    if(e.key === 'ArrowLeft' || e.key === 'a') keys.Left = true;
    if(e.key === 'ArrowRight' || e.key === 'd') keys.Right = true;
});
window.addEventListener('keyup', e => {
    if(e.key === 'ArrowUp' || e.key === 'w') keys.Up = false;
    if(e.key === 'ArrowDown' || e.key === 's') keys.Down = false;
    if(e.key === 'ArrowLeft' || e.key === 'a') keys.Left = false;
    if(e.key === 'ArrowRight' || e.key === 'd') keys.Right = false;
});

window.addEventListener('resize', resize);

// Init
loadLevel(0);
draw();

</script>
</body>
</html>
